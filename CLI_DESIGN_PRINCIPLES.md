# Принципы Проектирования Высококачественных CLI-Утилит

Этот документ формулирует набор требований и принципов для создания элегантных, надежных и модульных утилит командной строки (CLI), соответствующих высшим стандартам разработки.

## 1. Философия и Принципы Проектирования

Основой для любой качественной CLI-утилиты служат проверенные временем принципы, уходящие корнями в философию UNIX.

*   **Принцип Единственной Ответственности (Do One Thing and Do It Well):** Утилита должна решать одну атомарную задачу, но решать ее идеально. Сложные рабочие процессы достигаются путем композиции простых утилит, а не созданием одной программы-комбайна.
*   **Композиция через Потоки (Expect the output of every program to become the input to another):** Утилита должна быть "хорошим гражданином" в конвейере (`pipeline`). Она обязана читать данные из стандартного ввода (`stdin`) и писать результат в стандартный вывод (`stdout`). Диагностические сообщения, логи и ошибки должны направляться исключительно в стандартный поток ошибок (`stderr`).
*   **Молчание — Золото (Silence is Golden):** Утилита не должна выводить ничего в `stdout`, если ей нечего сказать по существу. Успешное выполнение команды в большинстве случаев не требует никакого вывода. Это позволяет безопасно использовать ее в скриптах и конвейерах.
*   **Разговорчивость по Запросу:** Для интерактивного использования должен быть предусмотрен "разговорчивый" режим (`verbose`, флаг `-v`), который выводит в `stderr` подробную информацию о ходе выполнения.
*   **Предсказуемость и Детерминизм:** При одинаковых входных данных и конфигурации утилита должна всегда производить одинаковый результат. Внутреннее состояние не должно влиять на исход операции.

## 2. Интерфейс и Взаимодействие с Пользователем (UX/CLI)

Интерфейс — это контракт утилиты с пользователем. Он должен быть интуитивным, последовательным и самодокументируемым, следуя конвенциям POSIX.

*   **Стандартные Флаги и Опции:**
    *   `--help`, `-h`: Выводит исчерпывающую, но краткую справку.
    *   `--version`, `-V`: Выводит версию утилиты.
    *   `--verbose`, `-v`: Включает режим подробного вывода в `stderr`. Может быть "накапливаемым" (`-vvv`) для увеличения уровня детализации.
    *   `--quiet`, `-q`: Подавляет любой некритичный вывод (кроме фатальных ошибок).
*   **Соглашения по Флагам:** Следовать конвенциям POSIX. Короткие флаги (например, `-v`) могут группироваться (`-vqc`), длинные флаги (`--verbose`) должны быть описательными.
*   **Осмысленные Коды Возврата (Exit Codes):**
    *   `0`: Успешное выполнение.
    *   `>0`: Ошибка. Различные ненулевые коды должны соответствовать разным классам ошибок (например, `1` - общая ошибка, `2` - неверное использование/аргументы, `127` - команда не найдена), что позволяет использовать утилиту в скриптах для тонкой обработки сбоев.
*   **Интерактивный и Неинтерактивный Режимы:** Утилита должна автоматически определять, запущена ли она в интерактивном терминале (`isatty`). В интерактивном режиме допустимы цветной вывод, индикаторы прогресса, запросы подтверждения. В неинтерактивном режиме (например, в `cron` или CI/CD) весь "декор" и интерактивность должны быть отключены. Для принудительного отключения интерактивности должен существовать флаг `--no-input`, для принудительного подтверждения — `--yes` или `--force`.

## 3. Обработка данных и Потоки (I/O)

*   **Потоковая Обработка:** Данные должны обрабатываться потоково, а не загружаться целиком в память. Это позволяет работать с файлами и потоками данных практически неограниченного размера с минимальным потреблением RAM.
*   **Форматы Данных:** Для вывода, предназначенного для других программ, предпочтителен легко парсируемый, строко-ориентированный формат (JSONL, TSV). Для вывода, предназначенного для человека, — человекочитаемый текст (таблицы, списки). Утилита должна поддерживать переключение формата через флаг `--output-format`.

## 4. Конфигурация, Состояние и Секреты

*   **Приоритеты Конфигурации:** Должна соблюдаться четкая иерархия источников конфигурации (каждый последующий уровень переопределяет предыдущий):
    1.  Значения по умолчанию (вшитые в код).
    2.  Глобальный конфигурационный файл (например, `/etc/my-app/config.yaml`).
    3.  Пользовательский конфигурационный файл (например, `~/.config/my-app/config.yaml`).
    4.  Переменные окружения (например, `MY_APP_API_KEY`).
    5.  Флаги командной строки (например, `--api-key=...`).
*   **Отсутствие Скрытого Состояния:** Идеальная CLI-утилита — это чистая функция. Она не должна полагаться на результаты своего предыдущего запуска или хранить состояние между вызовами.
*   **Управление Секретами:** Секреты (пароли, токены) никогда не должны передаваться как флаги командной строки. Их следует передавать через переменные окружения, конфигурационные файлы с ограниченными правами доступа (`chmod 600`), системные хранилища секретов или через `stdin`.

## 5. Надежность и Отказоустойчивость

*   **Идемпотентность:** Если операция по своей природе может быть идемпотентной (например, создание конфигурации, применение миграции), повторный запуск утилиты с теми же аргументами не должен приводить к ошибке или нежелательным побочным эффектам после первого успешного запуска.
*   **Корректная Обработка Сигналов:** Утилита должна корректно обрабатывать сигналы операционной системы (SIGINT, SIGTERM), чтобы иметь возможность грациозно завершить работу: закончить текущую операцию, закрыть сетевые соединения, удалить временные файлы.
*   **Четкие Сообщения об Ошибках:** Сообщение об ошибке должно быть выведено в `stderr`, быть понятным пользователю и содержать контекст (например, имя файла и номер строки, где произошла ошибка) и, по возможности, подсказку о том, как исправить проблему.

## 6. Производительность

*   **Быстрый Запуск:** Время от запуска утилиты до начала выполнения полезной работы должно быть минимальным. Для утилит, написанных на интерпретируемых языках, это особенно критично.
*   **Эффективное Использование Ресурсов:** Утилита должна быть экономной в потреблении CPU и RAM. Следует избегать ненужных аллокаций памяти и неэффективных алгоритмов.
*   **Параллельная Обработка:** Для задач, которые можно распараллелить, утилита должна эффективно использовать доступные ядра процессора. Количество потоков/процессов должно настраиваться.

## 7. Модульность и Архитектура

*   **Разделение Ядра и Интерфейса:** Бизнес-логика приложения (ядро) должна быть полностью отделена от кода, отвечающего за парсинг аргументов и взаимодействие с консолью (интерфейс). Ядро должно быть оформлено как независимая библиотека, что позволяет:
    *   Использовать его как API в других программах.
    *   Легко тестировать логику независимо от интерфейса.
    *   Менять CLI-фреймворк (например, с `clap` на `argh`), не затрагивая ядро.

## 8. Тестирование

*   **Многоуровневое Тестирование:**
    *   **Unit-тесты:** Для отдельных функций и модулей ядра. Покрытие кода должно быть близко к 100%.
    *   **Интеграционные тесты:** Для проверки взаимодействия модулей ядра.
    *   **Сквозные (End-to-end) тесты:** Тестирование утилиты как "черного ящика" путем запуска ее как отдельного процесса и анализа ее кода возврата, `stdout` и `stderr` на наборе типовых и краевых сценариев.

## 9. Документация

*   **Самодокументируемый Код и Интерфейс:** Четкие имена переменных, функций и флагов.
*   **Встроенная Справка (`--help`):** Краткая и исчерпывающая.
*   **Man-страницы и/или `README.md`:** Подробное руководство с примерами использования для всех основных сценариев, описанием всех опций и кодов возврата.

## 10. Распространение и Установка

*   **Минимальные Зависимости:** Чем меньше у утилиты внешних зависимостей времени исполнения, тем проще ее устанавливать и использовать.
*   **Статические Бинарники:** Для компилируемых языков (Go, Rust) предпочтительно распространение в виде единственного статического бинарного файла без зависимостей от системных библиотек.
*   **Пакетные Менеджеры:** Предоставление пакетов для основных системных (apt, yum, brew) и языковых (pip, npm) пакетных менеджеров является стандартом для удобства пользователей.
